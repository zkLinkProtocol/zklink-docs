---
sidebar_position: 6
title: ' '

---

# Commit Block
zkLink L2 state machine is actuate by two kinds of events:

* L1 on-chain events
* L2 transactions

Different from protocols like zkSync who accept only one L1 on-chain event, zkLink can take multiple L1 on-chain events, which brings a problem: each L1 chain can only verify events from its own chain but fails to verify events from other chains. For example, a Validator may forge a BSC deposit and pack it to an Ethereum block that he commits, while Ethereum cannot verify this deposit.

To solve this problem, zkLink introduces the role of cross-chain bridge, who passes block information from chain to chain. Each L1 can verify its own on-chain events and pass this information to other L1s. In this case, L1s will be able to verify the correctness of the block data that Validator commits by collecting the verification information from all the other chains.

The on-chain events that need to be verified include: Deposit, ChangePubKey, Withdraw, ForcedExit, and FullExit; among which Deposit and FullExit is generated by L1, and L1 will also save this information. Each on-chain event contains a chainId that indicates the chain it is from.

Take Ethereum and BSC for example, the block pubdata committed by the Validator:

```
[op0][op1][op2][op3][op4][op5][op6]
Ethereum OP includes: op0, op3, op4
BSC OP includes: op1, op2, op5, op6
op0, op2, op4, and op5 are those that need to be verified by L1; op0 is a Deposit and op5 is a FullExit
```

According to chainId, Ethereum will only verify op0, op3, op4; and since op0 is a Deposit, Ethereum will also check it against the contract record. The verification process of BSC is similar to Ethereum. an offsetsCommitment is generated during verification process, indicating the position of op in pubdata. For example, the offsetsCommitment (regardless of the chuck of op) of this case is [1,0,1,0,1,1,0], where 1 indicates the op needs to be verified on-chain, otherwise it is 0.

the commitment of the block can be calculated by pubdata and offsetsCommitment.



```solidity
// below is pseudocode, the calculation needs to incorporate some other block information
commitment=sha256(pubdata+offsetsCommitment)
```

The cross-chain bridge will transmit this commitment among different L1s.

The potential malicious behavior of Validator:

* Can the Validator import a Polygon Deposit to the state machine?

  No, because the state machine specifies events from which chains can be taken as input.

* Can the Validator forge a BSC Deposit to the state machine?

  No, because Deposit will be uploaded to the contract, and checked against the contract record.

* Can the Validator forge a BSC Deposit to the state machine, without committing this Deposit in the block?

  No. The block can be committed, prove will fail because of different pubdata.

* Can a non-priority on-chain event verification such as Withdraw be omitted in the committed blockï¼Ÿ

  No. The block can be committed, prove will fail because of different pubdata.

* Can two identical state machines co-exist and forge a BSC Deposit in Ethereum state machine?

  No. The block can be committed, but the pubdata will be different from it on BSC, resulting in inconsistent commitment and failure of cross-chain block verification.


In summary, thanks to block verification via cross-chain bridge, Validator cannot play maliciously. But in the case above, since block pubdata committed to Ethereum contains a lot of non-Ethereum data, the cost of block commitment on Ethereum becomes considerably high. To solve this problem, zkLink introduces a brand-new block commit method: compressed block commit. block pubdata submitted to Ethereum will be trimmed - op that is not related to Ethereum on-chain events will be removed (including Transfer that is related to Ethereum)

```
// only below Ethereum block pubdata remain:
[op0][op4]
```

With some extra information uploaded:

```solidity
struct CompressedBlockExtraInfo {
	bytes32 publicDataHash; // pubdata hash of all chains
	bytes32 offsetCommitmentHash; // all chains pubdata offset commitment hash
	bytes32[] onchainOperationPubdataHashs; // onchain operation pubdata hash of the all other chains
}
```

Now the calculation of the commitment becomes:

```solidity
// below is pseudocode, the calculation needs to incorporate some other block information
commitment=sha256(sha256(pubdata)+sha256(offsetsCommitment))
```

Under uncompress mode, block commitment is calculated from pubdata, and in compressed block commit mode, block commitment can be calculated with extra information that Validator submits. Now let us continue with the potential malicious behavior from Validator:

* Can the validator tamper op4 (like Withdraw) data, such as changing owner to other address?

  Yes, since Ethereum contract can not verify op information like Withdraw, i.e, can not verify whether the op belongs to pubdata; but BSC has complete pubdata information, so BSC contract will be able to verify this information.

Thus, apart from commitment, the cross-chain bridge also need to transmit the pubdata hash of all on-chain event op. The process on BSC is:


```solidity
ethOnchainPubdataHash = keccak256(keccak256(op0)+op4)
bscOnchainPubdataHash = keccak256(keccak256(op2)+op5)
onchainPubdataHash = keccak256(ethOnchainPubdataHash+bscOnchainPubdataHash)
```
On Ethereum, the onchainOperationPubdataHashs of CompressedBlockExtraInfo is needed:

```solidity
ethOnchainPubdataHash = keccak256(keccak256(op0)+op4)
bscOnchainPubdataHash = onchainOperationPubdataHashs[BSC_CHAIN_ID]
onchainPubdataHash = keccak256(ethOnchainPubdataHash+bscOnchainPubdataHash)
```

By passing onchainPubdataHash, Validator on Ethereum will not be able to change, forge or leave out the op of on-chain events. In implementing the contract code, cross-chain block verification is realized by calculating syncHash from blockCommitment and onchainPubdataHash.
